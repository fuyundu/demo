package java8.lambda;

public class TestRunnalbe {
	public static void main(String[] args) {
		
		Runnable r = new Runnable() {
			
			@Override
			public void run() {
				System.out.println("匿名内部类1");
				
			}
		};

		
//		参数可以是零个或多个
//		参数类型可指定，可省略（根据表达式上下文推断）
//		参数包含在圆括号中，用逗号分隔
//		表达式主体可以是零条或多条语句,包含在花括号中
//		表达式主体只有一条语句时，花括号可省略
//		表达式主体有一条以上语句时，表达式的返回类型与代码块的返回类型一致
//		表达式只有一条语句时，表达式的返回类型与该语句的返回类型一致
//		//零个
//		()-> System.out.println("no argument");
//
//		//一个
//		x->x+1
		
		/*
		Lambda表达式允许直接以内联的形式为函数式接口的抽象方法提供实现，
		并把整个表达式作为函数式接口的实例（具体说来，是函数式接口一个具体实现的实例。
		用匿名内部类也可以完成同样的事情，只不过比较笨拙：需要提供一个实现，然后再直接内联将它实例化

		间接到难以置信
		Runnable只有一个run()方法，具体形式是 void run()，
		代表不接受参数也不返回值，将这个函数描述符和Lambda表达式的结构对应起来，()代表没有参数，
		System.out.println("Hello World 1")表示不返回值，所以可以得到：*/
		
		// lambda表达式是可传递的匿名函数的一种方式：它没有名称，但它有参数列表、函数主体、返回类型
		/* 因为lambda表达式本身就是一种内联的实现接口的方式，又因为没有名称，所以没有方法名run,因为run方法没有参数所以可直接写成(), 
		又因无返回值所以直接System输出即可,并且只有一条语名可以不用加｛｝,见上面说明*/
		Runnable rr = () -> System.out.println("lambda");  
		// 总结：lambda表达式就是直接写参数和方法体，之间用->分隔，本身就代表着接口的一种实现，所以用起来超简单。
		new Thread(r).start();
		new Thread(rr).start();
				
		/* 相对于内部类，lambda 表达式的语义就十分简单：它不会从超类（supertype）中继承任何变量名，也不会引入一个新的作用域。
		也就是说 lambda 表达式函数体里面的变量和它外部环境的变量具有相同的语义（也包括 lambda 表达式的形式参数）。
		此外，’this’ 关键字及其引用在 lambda 表达式内部和外部也拥有相同的语义。
		在 Java SE 7 中，编译器对内部类中引用的外部变量（即捕获的变量）要求非常严格：如果捕获的变量没有被声明为final就会产生一个编译错误。现在放宽了这个限制——对于 lambda 表达式和内部类，允许在其中捕获那些符合有效只读（Effectively final）的局部变量。

		简单的说，如果一个局部变量在初始化后从未被修改过，那么它就符合有效只读的要求，换句话说，加上final后也不会导致编译错误的局部变量就是有效只读变量。
		对this的引用，以及通过this对未限定字段的引用和未限定方法的调用在本质上都属于使用final局部变量。包含此类引用的 lambda 表达式相当于捕获了this实例。在其它情况下，lambda 对象不会保留任何对this的引用。
		这个特性对内存管理是一件好事：内部类实例会一直保留一个对其外部类实例的强引用，而那些没有捕获外部类成员的 lambda 表达式则不会保留对外部类实例的引用。要知道内部类的这个特性往往会造成内存泄露。
		*/
	}
}
